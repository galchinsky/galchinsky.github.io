---
layout : post
title : Поваренная книга обработки картинок
---

Здесь будут собираны рецепты по имитации эффектов различных пунктов меню в фотошопе. Полезно, например, для создания пайплайна предобработки в классическом компьютерном зрении или для аугментации данных в глубоком обучении.

## Попиксельные обработки - яркость, контраст, уровни, кривые и гамма

Все эти обработки берут значение пикселя и применяют к нему какую-то функцию, и записывают результат назад. Каждый пиксель обрабатывается независимо. Таким образом, все, что отличает эти операции, это вид применяемой функции. "Кривые" дают самую наглядную визуализацию и являются самым мощным и наглядным вариантом. Остальные обработки создают какую-то свою кривую под капотом, но ее не демонстрируют. Поэтому для окончательных тестов того, а что такого закодить, рекомендую переходить сразу к кривым.

### Яркость и контраст

Простейший случай - получить новое изображение, применив линейную функцию `k*x + b` к яркости каждого пикселя. C numpy это просто:

```
new_img = k * img + b
```

Число b отвечает за яркость, k - за kontrast. img - матрица с картинкой.

В результате возможен выход самых ярких пикселей за пределы. Если это не допустимо, все, что ниже 0 и выше 1 превращаем в 0 и 1:

```
new_img = np.clip(k * img + b, 0, 1)
```

Параметр b точно соответствует яркости в редакторе - 0 означает отсутствие изменений, идем в плюс - увеличиваем яркость, в минус - все тусклее.

С параметром k сложнее, потому что в том виде, как он тут написан, он управляет наклоном функции относительно точки пересечения прямой и оси Y (0; b). Это не совсем интуитивный контраст. Для более интуитивного подхода требуется вращать вокруг точки (0.5, 0.5):

```
new_img = k*(img - 0.5) + b + 0.5
```

Сам параметр k может быть также нелинейно привязан к крутилке в UI, и как оно сделано в конкретном редакторе - вопрос. 

### Максимизация контраста

Иногда требуется максимизировать контраст, то есть, чтобы самый тусклый пиксель имел значение точно 0, самый яркий точно 1:

```
min_pixel = np.minimum(img)
max_pixel = np.minimum(img)
max_contrast_img = (img - min_pixel) / (max_pixel - min_pixel)
```

### Уровни

Уровни применяют такую же `k*x+b`, но через UI задаются значения этой функции для самого темного и яркого пикселей. Есть более продвинутая версия, где помимо черного и белого ползунка есть еще серый, midpoint. Здесь уже не прямая, а изогнутая кривая.

### Кривые

С помощью пункта меню "кривые" можно нарисовать функцию непосредственно в UI. Если функция кусочно-линейная, ее можно описать с помощью np.interp. Например, вот так можно сделать что-то вроде изменения контраста:

```
new_img = numpy.interp(img, [0, 1], [0.3, 0.8])
```

Аппроксимация гамма-коррекции с помощью двух отрезков:

```
new_img = numpy.interp(img, [0, 0.5, 1], [0, 0.8, 1])
```

Для более гладкой кривой интерполировать сплайнами:

```
tck = interpolate.splrep([0, 0.5, 1], [0, 0.8, 1], s=0)
xnew = np.linspace(0, 1, 100)
ynew = interpolate.splev(xnew, tck, der=0)
```

### Реверс попиксельного алгоритма

Если накрутили что-то в редакторе и нужно перенести это в скрипт, то для реверса нужно создать файл без сжатия со всеми 255 оттенками серого, обработать его настройкой, и сохранить результат, и путем сравнения оригинального и обработанного файлов реверснуть обработку.

## Размытие

Выбор по умолчанию - размытие по Гауссу. Оно довольно неплохо имитирует то, что происходит в расфокусированной оптике. Параметр sigma управляет величиной размытия. Для совсем ленивых есть уже готовая функция в scipy:

```python
filtered_image = scipy.ndimage.gaussian_filter(input, sigma)
```

<!--
Внутри оно делает две вещи - создает матрицу с ядром размытия, и выполняет операцию свертки картинки с этим ядром. Ядро размытие у нас - функция Гаусса, которую в 2Д обернули вокруг своей оси и получили размытый круг. Можно расписать это самим:

```python

```

Если требуется что-то более замороченное, например, motion blur, сама операция свертки остается, но нужно поменять ядро.

```python
```

### Реверс размытия

Первым делом нужно определить, одинаковое ли размытие везде в картинке, или в разных областях размывается по-разному. Для этого делаем белый файл с черными точками в виде сетки и обрабатываем фильтром.

* Если результирующие размытые точки везде одинаковые - ура. Измеряем величину размытого пятна в пикселях. Затем создаем черный файл такого размера и устанавливаем посередине белую точку:

```python
```

Обрабатываем ее в редакторе. Получаенная картинка - это и есть то ядро, которое нужно скормить в convolve2d.

* Если результирующие точки разные - все сложнее, но подход тот же. Нужно скормить гимпу сетку точек, выделить из размытого файла ядра, и дальше интерполировать между разными ядрами при применении свертки.

* Примерно такой же подход применяется, если в распоряжении есть функции рассеяния из программы оптического расчета


-->
